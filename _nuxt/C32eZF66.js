import{k as d,W as k,V as v,g as N,X as x,Y as j,Z as l,$ as P,H as g,a0 as S,a1 as _,h,R as y,x as w,z as O,a2 as T,I as R,a3 as A,a4 as c,a5 as B}from"#entry";const E=d({name:"LayoutLoader",inheritAttrs:!1,props:{name:String,layoutProps:Object},setup(e,a){return()=>y(l[e.name],e.layoutProps,a.slots)}}),H={name:{type:[String,Boolean,Object],default:null},fallback:{type:[String,Object],default:null}},I=d({name:"NuxtLayout",inheritAttrs:!1,props:H,setup(e,a){const t=k(),n=g(c),u=!n||n===v()?P():n,o=N(()=>{let s=h(e.name)??u?.meta.layout??"default";return s&&!(s in l)&&e.fallback&&(s=h(e.fallback)),s}),i=x();a.expose({layoutRef:i});const r=t.deferHydration();if(t.isHydrating){const s=t.hooks.hookOnce("app:error",r);j().beforeEach(s)}let f;return()=>{const s=o.value&&o.value in l,p=u?.meta.layoutTransition??S,b=f;return f=o.value,_(s&&p,{default:()=>y(T,{suspensible:!0,onResolve:()=>{O(r)}},{default:()=>y(C,{layoutProps:w(a.attrs,{ref:i}),key:o.value||void 0,name:o.value,shouldProvide:!e.name,isRenderingNewLayout:m=>m!==b&&m===o.value,hasTransition:!!p},a.slots)})}).default()}}}),C=d({name:"NuxtLayoutProvider",inheritAttrs:!1,props:{name:{type:[String,Boolean]},layoutProps:{type:Object},hasTransition:{type:Boolean},shouldProvide:{type:Boolean},isRenderingNewLayout:{type:Function,required:!0}},setup(e,a){const t=e.name;e.shouldProvide&&R(B,{isCurrent:u=>t===(u.meta.layout??"default")});const n=g(c);if(n&&n===v()){const u=P(),o={};for(const i in u){const r=i;Object.defineProperty(o,r,{enumerable:!0,get:()=>e.isRenderingNewLayout(e.name)?u[r]:n[r]})}R(c,A(o))}return()=>!t||typeof t=="string"&&!(t in l)?a.slots.default?.():y(E,{key:t,layoutProps:e.layoutProps,name:t},a.slots)}});export{I as _};
